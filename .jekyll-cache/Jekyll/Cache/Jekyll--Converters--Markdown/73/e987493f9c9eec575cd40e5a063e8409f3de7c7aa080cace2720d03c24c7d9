I"~<!--more-->
<p>对《C++ Concurrency In Action》第4.4.2部分的一个记录，主要介绍了如何使用消息队列来实现线程间的交互。这种做法叫做Communicating Sequential Processes，简称CSP，其思路就是如果线程间没有共享的数据那么分析起来就会简单很多，我们只需要考虑每个线程在收到特定的消息时的行为即可，每个线程可以视作一个有限状态机</p>

<h3 id="atm机的实现思路">ATM机的实现思路</h3>
<p>现在思考一下ATM机的工作流程，初始状态什么都没有，当插入银行卡后会进入输入密码的环节，此时可以输入密码、回退或是取消。当输入6个数字后进行密码校验，如果成功则进入账户页面。账户页面可以取款、查询余额，取款时需要输入金额并向银行确认交易结果，成功则机器取出对应的钞票，否则提示失败。总体上来看我们可以分成三个独立的线程：</p>
<ol>
  <li>逻辑线程：处理用户输入、状态流转</li>
  <li>硬件线程：展示对应信息、提取现金</li>
  <li>银行线程：校验密码和余额情况</li>
</ol>

<h3 id="流程图">流程图</h3>
<p><img src="/assets/images/ATM.png" alt="Image" /></p>

<h3 id="具体实现">具体实现</h3>
<p>首先实现一个消息队列的模型，支持任意类型的消息</p>
<h4 id="message类">Message类</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">//</span> <span class="err">基类</span>
<span class="n">struct</span> <span class="no">MessageBase</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="n">virtual</span> <span class="o">~</span><span class="no">MessageBase</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="sr">//</span> <span class="err">包装类，模板参数指定消息类型</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="no">Message</span><span class="o">&gt;</span>
<span class="n">struct</span> <span class="no">WrapperMessage</span> <span class="p">:</span> <span class="kp">public</span> <span class="no">MessageBase</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="n">explicit</span> <span class="no">WrapperMessage</span><span class="p">(</span><span class="n">const</span> <span class="no">Message</span><span class="o">&amp;</span> <span class="n">content</span><span class="p">)</span> <span class="p">:</span> <span class="n">content_</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="p">{}</span>
  <span class="no">Message</span> <span class="n">content_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="messagequeue类">MessageQueue类</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">//</span> <span class="err">使用互斥锁和条件变量管理的消息队列</span>
<span class="k">class</span> <span class="nc">MessageQueue</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="no">Message</span><span class="o">&gt;</span>
  <span class="n">void</span> <span class="no">Push</span><span class="p">(</span><span class="n">const</span> <span class="no">Message</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lg</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
    <span class="n">queue_</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="no">WrapperMessage</span><span class="o">&lt;</span><span class="no">Message</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
    <span class="n">cv_</span><span class="p">.</span><span class="nf">notify_all</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="no">MessageBase</span><span class="o">&gt;</span> <span class="no">WaitAndPop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span><span class="n">m_</span><span class="p">);</span>
    <span class="n">cv_</span><span class="p">.</span><span class="nf">wait</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">queue_</span><span class="p">.</span><span class="nf">empty</span><span class="p">();</span>
    <span class="p">});</span>
    <span class="n">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">queue_</span><span class="p">.</span><span class="nf">front</span><span class="p">();</span>
    <span class="n">queue_</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="no">MessageBase</span><span class="o">&gt;&gt;</span> <span class="n">queue_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="sender和receiver类">Sender和Receiver类</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sr">//</span> <span class="no">Sender</span><span class="err">类引用一个消息队列，并向其推送自定义消息</span>
<span class="k">class</span> <span class="nc">Sender</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="n">explicit</span> <span class="no">Sender</span><span class="p">(</span><span class="no">MessageQueue</span><span class="o">*</span> <span class="n">queue</span><span class="p">)</span> <span class="p">:</span> <span class="n">queue_</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="no">Message</span><span class="o">&gt;</span>
  <span class="n">void</span> <span class="no">Send</span><span class="p">(</span><span class="n">const</span> <span class="no">Message</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue_</span><span class="o">-&gt;</span><span class="no">Push</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="no">MessageQueue</span><span class="o">*</span> <span class="n">queue_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="sr">//</span> <span class="no">Receiver</span><span class="err">类持有一个消息队列，创建</span><span class="no">Dispatcher</span><span class="err">类来处理其中的消息。支持转化为</span><span class="no">Sender</span><span class="err">来利用其中的队列发送消息</span>
<span class="k">class</span> <span class="nc">Receiver</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="no">Dispatcher</span> <span class="no">Wait</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">Dispatcher</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">operator</span> <span class="no">Sender</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">Sender</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="no">MessageQueue</span> <span class="n">queue_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="dispatcher类">Dispatcher类</h4>
<p><code class="language-plaintext highlighter-rouge">Dispatcher</code>类是一个专门负责分发消息的类，当它析构时它会尝试将对应队列中所有的消息分发出去。这其实只是一个兜底操作，大多数情况是通过调用<code class="language-plaintext highlighter-rouge">Handle</code>函数来处理特定的消息。注意这里的<code class="language-plaintext highlighter-rouge">chained_</code>成员变量用来标记这个Dispatcher是不是已经“链”进去了，主要是避免重复进行分发。在实现中我们将<code class="language-plaintext highlighter-rouge">Dispatcher</code>一个个链起来处理消息的时候会看的更清楚
<code class="language-plaintext highlighter-rouge">TemplateDispatcher</code>和<code class="language-plaintext highlighter-rouge">Dispatcher</code>类几乎一样，但是增加了处理的Message和Func作为模板参数</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">struct</span> <span class="no">CloseQueue</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">Dispatcher</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="n">explicit</span> <span class="no">Dispatcher</span><span class="p">(</span><span class="no">MessageQueue</span><span class="o">*</span> <span class="n">queue</span><span class="p">)</span> <span class="p">:</span> <span class="n">queue_</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="p">{}</span>
  <span class="no">Dispatcher</span><span class="p">(</span><span class="no">Dispatcher</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">:</span> <span class="n">queue_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">queue_</span><span class="p">),</span> <span class="n">chained_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">chained_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="nf">chained_</span> <span class="o">=</span> <span class="kp">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="no">Dispatcher</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chained_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="no">WaitAndDispatch</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="no">Dispatcher</span><span class="p">(</span><span class="n">const</span> <span class="no">Dispatcher</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
  <span class="no">Dispatcher</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span> <span class="no">Dispatcher</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="no">Dispatcher</span><span class="p">,</span> <span class="n">typename</span> <span class="no">Msg</span><span class="p">,</span> <span class="n">typename</span> <span class="no">Func</span><span class="o">&gt;</span>
  <span class="n">friend</span> <span class="k">class</span> <span class="nc">TemplateDispatcher</span><span class="p">;</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="no">Message</span><span class="p">,</span> <span class="n">typename</span> <span class="no">Func</span><span class="o">&gt;</span>
  <span class="no">TemplateDispatcher</span><span class="o">&lt;</span><span class="no">Dispatcher</span><span class="p">,</span> <span class="no">Message</span><span class="p">,</span> <span class="no">Func</span><span class="o">&gt;</span> <span class="no">Handle</span><span class="p">(</span><span class="no">Func</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">TemplateDispatcher</span><span class="p">(</span><span class="n">queue_</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="no">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="no">Dispatch</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="no">MessageBase</span><span class="o">&gt;&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="no">WrapperMessage</span><span class="o">&lt;</span><span class="no">CloseQueue</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="nf">get</span><span class="p">()))</span> <span class="p">{</span>
        <span class="kp">throw</span> <span class="no">CloseQueue</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kp">false</span><span class="p">;</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="n">void</span> <span class="no">WaitAndDispatch</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">auto</span> <span class="n">message</span> <span class="o">=</span> <span class="n">queue_</span><span class="o">-&gt;</span><span class="no">WaitAndPop</span><span class="p">();</span>
        <span class="no">Dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="no">MessageQueue</span><span class="o">*</span> <span class="n">queue_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">bool</span> <span class="n">chained_</span> <span class="o">=</span> <span class="kp">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="no">PreviousDispatcher</span><span class="p">,</span> <span class="n">typename</span> <span class="no">Message</span><span class="p">,</span> <span class="n">typename</span> <span class="no">Func</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TemplateDispatcher</span> <span class="p">{</span>
<span class="ss">public:
  </span><span class="no">TemplateDispatcher</span><span class="p">(</span><span class="no">MessageQueue</span><span class="o">*</span> <span class="n">queue</span><span class="p">,</span> <span class="no">PreviousDispatcher</span><span class="o">*</span> <span class="n">previous</span><span class="p">,</span> <span class="no">Func</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">:</span>
  <span class="n">queue_</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span> <span class="n">chained_</span><span class="p">(</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">chained_</span><span class="p">),</span> <span class="n">previous_</span><span class="p">(</span><span class="n">previous</span><span class="p">),</span> <span class="n">f_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="no">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">previous</span><span class="o">-&gt;</span><span class="n">chained_</span> <span class="o">=</span> <span class="kp">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="no">TemplateDispatcher</span><span class="p">(</span><span class="no">TemplateDispatcher</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">:</span>
  <span class="n">queue_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">queue_</span><span class="p">),</span> <span class="n">chained_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">chained_</span><span class="p">),</span> <span class="n">previous_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">previous_</span><span class="p">),</span> <span class="n">f_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="nf">f_</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="nf">chained_</span> <span class="o">=</span> <span class="kp">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="no">TemplateDispatcher</span><span class="p">(</span><span class="n">const</span> <span class="no">TemplateDispatcher</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
  <span class="no">TemplateDispatcher</span> <span class="o">&amp;</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span> <span class="no">TemplateDispatcher</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="no">Dispatcher</span><span class="p">,</span> <span class="n">typename</span> <span class="no">OtherMsg</span><span class="p">,</span> <span class="n">typename</span> <span class="no">OtherFunc</span><span class="o">&gt;</span>
  <span class="n">friend</span> <span class="k">class</span> <span class="nc">TemplateDispatcher</span><span class="p">;</span>
  
  <span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="no">OtherMessage</span><span class="p">,</span> <span class="n">typename</span> <span class="no">OtherFunc</span><span class="o">&gt;</span>
  <span class="no">TemplateDispatcher</span><span class="o">&lt;</span><span class="no">TemplateDispatcher</span><span class="p">,</span> <span class="no">OtherMessage</span><span class="p">,</span> <span class="no">OtherFunc</span><span class="o">&gt;</span> <span class="no">Handle</span><span class="p">(</span><span class="no">OtherFunc</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="no">TemplateDispatcher</span><span class="p">(</span><span class="n">queue_</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="no">OtherFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="no">TemplateDispatcher</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chained_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="no">WaitAndDispatch</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="no">Dispatch</span><span class="p">(</span><span class="n">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="no">MessageBase</span><span class="o">&gt;&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">auto</span><span class="o">*</span> <span class="n">wrapper_message</span> <span class="o">=</span> <span class="n">dynamic_cast</span><span class="o">&lt;</span><span class="no">WrapperMessage</span><span class="o">&lt;</span><span class="no">Message</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="nf">get</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">f_</span><span class="p">(</span><span class="n">wrapper_message</span><span class="o">-&gt;</span><span class="n">content_</span><span class="p">);</span>
        <span class="k">return</span> <span class="kp">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">previous_</span><span class="o">-&gt;</span><span class="no">Dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kp">false</span><span class="p">;</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="n">void</span> <span class="no">WaitAndDispatch</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">auto</span> <span class="n">message</span> <span class="o">=</span> <span class="n">queue_</span><span class="o">-&gt;</span><span class="no">WaitAndPop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="no">Dispatch</span><span class="p">(</span><span class="n">message</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="ss">private:
  </span><span class="no">MessageQueue</span><span class="o">*</span> <span class="n">queue_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">bool</span> <span class="n">chained_</span> <span class="o">=</span> <span class="kp">false</span><span class="p">;</span>
  <span class="no">PreviousDispatcher</span><span class="o">*</span> <span class="n">previous_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="no">Func</span> <span class="n">f_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Dispatcher使用实例：</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Receiver</span> <span class="n">receiver</span><span class="p">;</span>
<span class="n">receiver</span><span class="o">.</span><span class="no">Wait</span><span class="p">()</span><span class="o">.</span><span class="no">Handle</span><span class="o">&lt;</span><span class="no">Message1</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">const</span> <span class="no">Message1</span><span class="o">&amp;</span><span class="p">){</span>
  <span class="sr">//</span> <span class="no">Do</span> <span class="n">something</span><span class="o">...</span>
<span class="p">})</span><span class="o">.</span><span class="no">Handle</span><span class="o">&lt;</span><span class="no">Message2</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">const</span> <span class="no">Message2</span><span class="o">&amp;</span><span class="p">){</span>
  <span class="sr">//</span> <span class="no">Do</span> <span class="n">something</span><span class="o">...</span>
<span class="p">});</span>
</code></pre></div></div>
<p>过程分析：</p>
<ul>
  <li>调用这行代码时会创建若干个<code class="language-plaintext highlighter-rouge">Dispatcher</code>和<code class="language-plaintext highlighter-rouge">TemplateDispatcher</code>对象，它们引用同一个<code class="language-plaintext highlighter-rouge">MessageQueue</code></li>
  <li>执行完这条语句后，从后向前依次调用每个对象的析构函数，如果队列中没有消息则阻塞在<code class="language-plaintext highlighter-rouge">WaitAndDispatch</code>方法，否则取出消息后试图进行分发，如果当前的<code class="language-plaintext highlighter-rouge">Dispatcher</code>处理不了（消息类型不匹配）就继续传递给前一个进行处理</li>
  <li>如果某条消息经过了处理，就从析构函数的无限循环中退出。由于<code class="language-plaintext highlighter-rouge">chained_</code>变量的存在，这条消息最多只会被处理一次</li>
</ul>

<h4 id="入口代码">入口代码</h4>
<p>在具体实现状态机前，可以先大致写出入口代码</p>
<ol>
  <li>我们需要三个对象来分别处理主状态机、硬件以及银行的逻辑</li>
  <li>这三个对象分别在三个线程上进行各自的工作</li>
  <li>它们通过消息队列来互相发送消息。例如初始状态状态机线程等待插入银行卡，当插入银行卡后由硬件线程输出一行欢迎语句，接下来主线程接受用户输入，并发送给状态机线程处理相关逻辑，输入完毕后则发送给银行线程进行校验……</li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
<span class="no">BankMachine</span> <span class="n">bank_machine</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">balance</span><span class="p">);</span>
<span class="no">HardwareMachine</span> <span class="n">hardware_machine</span><span class="p">;</span>
<span class="no">ATMMachine</span> <span class="n">atm_machine</span><span class="p">(</span><span class="n">bank_machine</span><span class="o">.</span><span class="no">GetSender</span><span class="p">(),</span>
                        <span class="n">hardware_machine</span><span class="o">.</span><span class="no">GetSender</span><span class="p">());</span>
<span class="n">messaging</span><span class="o">::</span><span class="no">Sender</span> <span class="n">sender</span><span class="p">(</span><span class="n">atm_machine</span><span class="o">.</span><span class="no">GetSender</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">thread</span> <span class="n">atm_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="no">ATMMachine</span><span class="o">::</span><span class="no">Run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atm_machine</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">thread</span> <span class="n">bank_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="no">BankMachine</span><span class="o">::</span><span class="no">Run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bank_machine</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">thread</span> <span class="n">hardware_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="no">HardwareMachine</span><span class="o">::</span><span class="no">Run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hardware_machine</span><span class="p">);</span>
<span class="o">...</span>

<span class="n">atm_machine</span><span class="o">.</span><span class="no">Done</span><span class="p">();</span>
<span class="n">hardware_machine</span><span class="o">.</span><span class="no">Done</span><span class="p">();</span>
<span class="n">bank_machine</span><span class="o">.</span><span class="no">Done</span><span class="p">();</span>
<span class="n">atm_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">();</span>
<span class="n">hardware_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">();</span>
<span class="n">bank_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">();</span>
</code></pre></div></div>

<p>剩下的过程其实就是慢慢根据状态流转图去完善这三个类了，具体代码这里就不详细列出了，可以直接在<a href="https://github.com/mikucy/ATMDemo">Github仓库</a>查看</p>
:ET